import inspect
import sys
import traceback
from datetime import datetime, timedelta
from os import getenv, mkdir
from os.path import exists as path_exists

import disnake
from disnake.ext import commands, tasks
from dotenv import load_dotenv
from exencolorlogs import Logger

from ai.train import train as train_ai
from utils import embeds
from utils.constants import EMOJIS, LOG_CHANNEL_ID, TRAIN_GUILD_IDS
from utils.datamodels import Database
from utils.views import AntispamView, ReportedNotSpamView, UnbanView, UntimeoutView

REQUIRED_FOLDERS = ("logs",)


class Bot(commands.Bot):
    def __init__(self, *, test_version: bool = False):
        intents = disnake.Intents.all()
        intents.presences = False
        self.log = Logger("BOT")
        kwrg = {}
        self.test_version = test_version
        if test_version:
            self.log.warning("Running on TEST VERSION")
            kwrg = {"test_guilds": TRAIN_GUILD_IDS}
        super().__init__(
            intents=intents,
            allowed_mentions=disnake.AllowedMentions(
                everyone=False, users=True, roles=False, replied_user=True
            ),
            **kwrg,
        )
        self.db: Database = Database()
        self.sys_emojis: embeds.Emojis = embeds.Emojis()
        self.log_channel: disnake.TextChannel = None
        self.warnings: WarningsManager = WarningsManager(self)

    async def start(self, *args, **kwargs):
        self.log.info("Establishing database connection...")
        await self.db.connect()
        await self.db.setup()

        if not self.test_version:
            self.log.info("Training AI model...")
            await train_ai(self.db)

        self.log.info("Loading extensions...")
        self.load_extensions("./ext")

        for folder in REQUIRED_FOLDERS:
            if not path_exists(folder):
                mkdir(folder)
                self.log.warning("Folder %s was missing so was autogenerated", folder)

        self.add_view(AntispamView())
        self.add_view(ReportedNotSpamView())
        self.add_view(UnbanView())
        self.add_view(UntimeoutView())
        self.log.info("Starting the bot...")
        await super().start(*args, **kwargs)

    async def close(self):
        self.log.info("Shutting down the bot...")
        await self.db.close()
        await super().close()

    def run(self):
        load_dotenv()
        token = getenv("TOKEN")
        if token is None or token == "":
            self.log.critical(
                ".env file filled improperly. Please see README.md for more information."
            )
            sys.exit(1)

        super().run(token)

    def load_emojis(self):
        for name, id in EMOJIS.items():
            setattr(self.sys_emojis, name, self.get_emoji(id))

    async def on_ready(self):
        self.log.ok("Bot is ready!")
        self.load_emojis()
        embeds.init(self.sys_emojis)

        self.log_channel = await self.fetch_channel(LOG_CHANNEL_ID)

    async def on_error(self, event_method: str, *args, **kwargs):
        self.log.error("Unhandled exception occured at %s", event_method)
        await self.log_error()

    async def log_error(self):
        now = datetime.now().date()
        month_path = f"logs/{now.month}"
        if not path_exists(month_path):
            mkdir(month_path)

        path = f"{month_path}/{now.day}.log.err"
        with open(path, "a") as f:
            f.write("\n" + "-" * 50)
            f.write(f"\n{datetime.now()}\n")
            tb = traceback.format_exc()
            f.write(tb)

        await self.log_channel.send(
            self.owner.mention,
            embed=disnake.Embed(
                colour=0xFF0000,
                title=f"{self.sys_emojis.exclamation} Unexpected error occured",
            ).add_field("Traceback (most recent call last):", tb[-1000:], inline=False),
            file=disnake.File(path),
        )

    def auto_setup(self, module_name: str):
        module = sys.modules[module_name]
        members = inspect.getmembers(
            module, lambda x: inspect.isclass(x) and issubclass(x, commands.Cog)
        )
        for member in members:
            self.add_cog(member[1](self))

        self.log.ok("%s loaded", module_name)


class WarningsManager:
    def __init__(self, bot: Bot):
        self.bot = bot
        self._warnings: dict[int, dict[int, int]] = {}

        self.warnings_reseter.start()

    @tasks.loop(minutes=5)
    async def warnings_reseter(self):
        for guild_id in self._warnings:
            for member_id in self._warnings[guild_id]:
                if self._warnings[guild_id][member_id] > 0:
                    self._warnings[guild_id][member_id] -= 1

    @warnings_reseter.before_loop
    async def loop_waiter(self):
        await self.bot.wait_until_ready()

    def get_warnings(self, author: disnake.Member):
        if not author.guild.id in self._warnings:
            self._warnings[author.guild.id] = {author.id: 0}
            return 0
        elif not author.id in self._warnings[author.guild.id]:
            self._warnings[author.guild.id][author.id] = 0
            return 0
        else:
            return self._warnings[author.guild.id][author.id]

    async def add_warning(self, message: disnake.Message):
        current_warnings = self.get_warnings(message.author)
        self._warnings[message.guild.id][message.author.id] += 1
        guild_data = self.bot.db.get_guild(message.guild.id)
        duration, threshold = await guild_data.get_warnings_data()
        if current_warnings >= threshold and message.author.current_timeout is None:
            await message.channel.send(
                f"**{self.bot.sys_emojis.checkmark} {message.author.mention}, enjoy your mute!**"
            )
            await message.author.timeout(
                duration=timedelta(minutes=duration),
                reason="Warnings threshold exceed.",
            )
            log = await guild_data.get_logger(self.bot)
            await log.log_timeout(message.author, duration)
            self._warnings[message.guild.id][message.author.id] = 0
            return -1
        else:
            return threshold - current_warnings
